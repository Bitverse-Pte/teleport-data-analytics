// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import (
	"encoding/json"
	"fmt"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *TokenInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		return fmt.Errorf("field address in TokenInfo: required")
	}
	if v, ok := raw["chainId"]; !ok || v == nil {
		return fmt.Errorf("field chainId in TokenInfo: required")
	}
	if v, ok := raw["decimals"]; !ok || v == nil {
		return fmt.Errorf("field decimals in TokenInfo: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in TokenInfo: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol in TokenInfo: required")
	}
	type Plain TokenInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Tags) > 10 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 10)
	}
	*j = TokenInfo(plain)
	return nil
}

// The name of a token extension property
type ExtensionIdentifier string

// An object containing any arbitrary or vendor-specific token metadata
type ExtensionMap map[string]interface{}

type ExtensionValue interface{}

type ExtensionValueInner0 interface{}

type ExtensionValueInner1 interface{}

// Definition of a tag that can be associated with a token via its identifier
type TagDefinition struct {
	// A user-friendly description of the tag
	Description string `json:"description" yaml:"description"`

	// The name of the tag
	Name string `json:"name" yaml:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TagDefinition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description in TagDefinition: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in TagDefinition: required")
	}
	type Plain TagDefinition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TagDefinition(plain)
	return nil
}

type ExtensionPrimitiveValue interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Version) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["major"]; !ok || v == nil {
		return fmt.Errorf("field major in Version: required")
	}
	if v, ok := raw["minor"]; !ok || v == nil {
		return fmt.Errorf("field minor in Version: required")
	}
	if v, ok := raw["patch"]; !ok || v == nil {
		return fmt.Errorf("field patch in Version: required")
	}
	type Plain Version
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Version(plain)
	return nil
}

// The unique identifier of a tag
type TagIdentifier string

// Metadata for a single token in a token list
type TokenInfo struct {
	// The checksummed address of the token on the specified chain ID
	Address string `json:"address" yaml:"address"`

	// The chain ID of the Ethereum network where this token is deployed
	ChainId string `json:"chainId" yaml:"chainId"`

	// The number of decimals for the token balance
	Decimals int `json:"decimals" yaml:"decimals"`

	// Extensions corresponds to the JSON schema field "extensions".
	Extensions ExtensionMap `json:"extensions,omitempty" yaml:"extensions,omitempty"`

	// A URI to the token logo asset; if not set, interface will attempt to find a
	// logo based on the token address; suggest SVG or PNG of size 64x64
	LogoURI *string `json:"logoURI,omitempty" yaml:"logoURI,omitempty"`

	// The name of the token
	Name string `json:"name" yaml:"name"`

	// The symbol for the token; must be alphanumeric
	Symbol string `json:"symbol" yaml:"symbol"`

	// An array of tag identifiers associated with the token; tags are defined at the
	// list level
	Tags []TagIdentifier `json:"tags,omitempty" yaml:"tags,omitempty"`
}

// Schema for lists of tokens compatible with the Uniswap Interface
type TokenlistSchemaJson struct {
	// Keywords associated with the contents of the list; may be used in list
	// discoverability
	Keywords []string `json:"keywords,omitempty" yaml:"keywords,omitempty"`

	// A URI for the logo of the token list; prefer SVG or PNG of size 256x256
	LogoURI *string `json:"logoURI,omitempty" yaml:"logoURI,omitempty"`

	// The name of the token list
	Name string `json:"name" yaml:"name"`

	// A mapping of tag identifiers to their name and description
	Tags TokenlistSchemaJsonTags `json:"tags,omitempty" yaml:"tags,omitempty"`

	// The timestamp of this list version; i.e. when this immutable version of the
	// list was created
	Timestamp string `json:"timestamp" yaml:"timestamp"`

	// The list of tokens included in the list
	Tokens []TokenInfo `json:"tokens" yaml:"tokens"`

	// Version corresponds to the JSON schema field "version".
	Version Version `json:"version" yaml:"version"`
}

// A mapping of tag identifiers to their name and description
type TokenlistSchemaJsonTags map[string]TagDefinition

// The version of the list, used in change detection
type Version struct {
	// The major version of the list. Must be incremented when tokens are removed from
	// the list or token addresses are changed.
	Major int `json:"major" yaml:"major"`

	// The minor version of the list. Must be incremented when tokens are added to the
	// list.
	Minor int `json:"minor" yaml:"minor"`

	// The patch version of the list. Must be incremented for any changes to the list.
	Patch int `json:"patch" yaml:"patch"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TokenlistSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in TokenlistSchemaJson: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp in TokenlistSchemaJson: required")
	}
	if v, ok := raw["tokens"]; !ok || v == nil {
		return fmt.Errorf("field tokens in TokenlistSchemaJson: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in TokenlistSchemaJson: required")
	}
	type Plain TokenlistSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Keywords) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "keywords", 20)
	}
	if len(plain.Tokens) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tokens", 1)
	}
	if len(plain.Tokens) > 10000 {
		return fmt.Errorf("field %s length: must be <= %d", "tokens", 10000)
	}
	*j = TokenlistSchemaJson(plain)
	return nil
}
