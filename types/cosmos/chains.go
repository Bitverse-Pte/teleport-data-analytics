// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package cosmos

import (
	"encoding/json"
	"fmt"

	"github.com/sirupsen/logrus"
)

type Bech32Config struct {
	// Bech32PrefixAccAddr corresponds to the JSON schema field "bech32PrefixAccAddr".
	Bech32PrefixAccAddr string `json:"bech32PrefixAccAddr" yaml:"bech32PrefixAccAddr"`

	// Bech32PrefixAccPub corresponds to the JSON schema field "bech32PrefixAccPub".
	Bech32PrefixAccPub string `json:"bech32PrefixAccPub" yaml:"bech32PrefixAccPub"`

	// Bech32PrefixConsAddr corresponds to the JSON schema field
	// "bech32PrefixConsAddr".
	Bech32PrefixConsAddr string `json:"bech32PrefixConsAddr" yaml:"bech32PrefixConsAddr"`

	// Bech32PrefixConsPub corresponds to the JSON schema field "bech32PrefixConsPub".
	Bech32PrefixConsPub string `json:"bech32PrefixConsPub" yaml:"bech32PrefixConsPub"`

	// Bech32PrefixValAddr corresponds to the JSON schema field "bech32PrefixValAddr".
	Bech32PrefixValAddr string `json:"bech32PrefixValAddr" yaml:"bech32PrefixValAddr"`

	// Bech32PrefixValPub corresponds to the JSON schema field "bech32PrefixValPub".
	Bech32PrefixValPub string `json:"bech32PrefixValPub" yaml:"bech32PrefixValPub"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Bech32Config) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bech32PrefixAccAddr"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixAccAddr in Bech32Config: required")
	}
	if v, ok := raw["bech32PrefixAccPub"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixAccPub in Bech32Config: required")
	}
	if v, ok := raw["bech32PrefixConsAddr"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixConsAddr in Bech32Config: required")
	}
	if v, ok := raw["bech32PrefixConsPub"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixConsPub in Bech32Config: required")
	}
	if v, ok := raw["bech32PrefixValAddr"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixValAddr in Bech32Config: required")
	}
	if v, ok := raw["bech32PrefixValPub"]; !ok || v == nil {
		return fmt.Errorf("field bech32PrefixValPub in Bech32Config: required")
	}
	type Plain Bech32Config
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Bech32Config(plain)
	return nil
}

type Bip44 struct {
	// CoinType corresponds to the JSON schema field "coinType".
	CoinType string `json:"coinType" yaml:"coinType"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Bip44) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["coinType"]; !ok || v == nil {
		return fmt.Errorf("field coinType in Bip44: required")
	}
	type Plain Bip44
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Bip44(plain)
	return nil
}

type CosmosChains struct {
	// Chains corresponds to the JSON schema field "chains".
	Chains []Chain `json:"chains" yaml:"chains"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Currency) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["coinDecimals"]; !ok || v == nil {
		return fmt.Errorf("field coinDecimals in Currency: required")
	}
	if v, ok := raw["coinDenom"]; !ok || v == nil {
		return fmt.Errorf("field coinDenom in Currency: required")
	}
	if v, ok := raw["coinMinimalDenom"]; !ok || v == nil {
		return fmt.Errorf("field coinMinimalDenom in Currency: required")
	}
	type Plain Currency
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Currency(plain)
	return nil
}

type GasPriceStep struct {
	// Average corresponds to the JSON schema field "average".
	Average string `json:"average" yaml:"average"`

	// High corresponds to the JSON schema field "high".
	High string `json:"high" yaml:"high"`

	// Low corresponds to the JSON schema field "low".
	Low string `json:"low" yaml:"low"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GasPriceStep) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["average"]; !ok || v == nil {
		return fmt.Errorf("field average in GasPriceStep: required")
	}
	if v, ok := raw["high"]; !ok || v == nil {
		return fmt.Errorf("field high in GasPriceStep: required")
	}
	if v, ok := raw["low"]; !ok || v == nil {
		return fmt.Errorf("field low in GasPriceStep: required")
	}
	type Plain GasPriceStep
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GasPriceStep(plain)
	return nil
}

type Chain struct {
	// Bech32Config corresponds to the JSON schema field "bech32Config".
	Bech32Config Bech32Config `json:"bech32Config" yaml:"bech32Config"`

	// Bip44 corresponds to the JSON schema field "bip44".
	Bip44 Bip44 `json:"bip44" yaml:"bip44"`

	// ChainId corresponds to the JSON schema field "chainId".
	ChainId string `json:"chainId" yaml:"chainId"`

	// ChainName corresponds to the JSON schema field "chainName".
	ChainName string `json:"chainName" yaml:"chainName"`

	// CoinType corresponds to the JSON schema field "coinType".
	CoinType string `json:"coinType" yaml:"coinType"`

	// Currencies corresponds to the JSON schema field "currencies".
	Currencies []Currency `json:"currencies" yaml:"currencies"`

	// FeeCurrencies corresponds to the JSON schema field "feeCurrencies".
	FeeCurrencies []Currency `json:"feeCurrencies" yaml:"feeCurrencies"`

	// GasPriceStep corresponds to the JSON schema field "gasPriceStep".
	GasPriceStep GasPriceStep `json:"gasPriceStep" yaml:"gasPriceStep"`

	// Rest corresponds to the JSON schema field "rest".
	Rest string `json:"rest" yaml:"rest"`

	// Rpc corresponds to the JSON schema field "rpc".
	Rpc string `json:"rpc" yaml:"rpc"`

	// StakeCurrency corresponds to the JSON schema field "stakeCurrency".
	StakeCurrency Currency `json:"stakeCurrency" yaml:"stakeCurrency"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Chain) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bech32Config"]; !ok || v == nil {
		return fmt.Errorf("field bech32Config in Chain: required")
	}
	if v, ok := raw["bip44"]; !ok || v == nil {
		return fmt.Errorf("field bip44 in Chain: required")
	}
	if v, ok := raw["chainId"]; !ok || v == nil {
		return fmt.Errorf("field chainId in Chain: required")
	}
	if v, ok := raw["chainName"]; !ok || v == nil {
		return fmt.Errorf("field chainName in Chain: required")
	}
	if v, ok := raw["coinType"]; !ok || v == nil {
		return fmt.Errorf("field coinType in Chain: required")
	}
	if v, ok := raw["currencies"]; !ok || v == nil {
		return fmt.Errorf("field currencies in Chain: required")
	}
	if v, ok := raw["feeCurrencies"]; !ok || v == nil {
		return fmt.Errorf("field feeCurrencies in Chain: required")
	}
	if v, ok := raw["gasPriceStep"]; !ok || v == nil {
		return fmt.Errorf("field gasPriceStep in Chain: required")
	}
	if v, ok := raw["rest"]; !ok || v == nil {
		return fmt.Errorf("field rest in Chain: required")
	}
	if v, ok := raw["rpc"]; !ok || v == nil {
		return fmt.Errorf("field rpc in Chain: required")
	}
	if v, ok := raw["stakeCurrency"]; !ok || v == nil {
		return fmt.Errorf("field stakeCurrency in Chain: required")
	}
	type Plain Chain
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Chain(plain)
	return nil
}

type Currency struct {
	// CoinDecimals corresponds to the JSON schema field "coinDecimals".
	CoinDecimals string `json:"coinDecimals" yaml:"coinDecimals"`

	// CoinDenom corresponds to the JSON schema field "coinDenom".
	CoinDenom string `json:"coinDenom" yaml:"coinDenom"`

	// CoinMinimalDenom corresponds to the JSON schema field "coinMinimalDenom".
	CoinMinimalDenom string `json:"coinMinimalDenom" yaml:"coinMinimalDenom"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CosmosChains) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["chains"]; !ok || v == nil {
		logrus.Errorf("field chains in CosmosChains: not exist")
		return nil
	}
	type Plain CosmosChains
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CosmosChains(plain)
	return nil
}
